## 迭代器

### 创建
有三种常见的方法可以从集合中创建迭代器：
+`iter()`，它在 `&T` 上迭代。(遍历型)
+`iter_mut()`，它在 `&mut T` 上迭代。(可变型)
+`into_iter()`，它在 `T` 上迭代。(消耗型)

而从迭代器生成集合类型:
+`:CollType=collect()`

### Adapters
通过Adapters,迭代器发生`iter->iter`的改变,使用了适配器模式

+`map()`：对迭代器中的每个元素应用一个函数，并返回一个新的迭代器。

+`filter()`：根据指定的条件过滤迭代器中的元素，并返回一个新的迭代器。

+`cycle()` : 创建一个无限循环的迭代器,直到被终止(一般使用`take(i32)`终止取指定个数)

+`take()`：从迭代器中获取指定数量的元素，并返回一个新的迭代器。

+`skip()`：跳过迭代器中的指定数量的元素，并返回一个新的迭代器。

+`enumerate()`：将迭代器中的元素和它们的索引组成一个元组，并返回一个新的迭代器。

+`zip()`：将两个迭代器中的元素一一对应地组成一个元组，并返回一个新的迭代器。

+`flat_map()`：对迭代器中的每个元素应用一个函数，并将结果展平为一个新的迭代器。

+`chain()`：将两个迭代器连接起来，并返回一个新的迭代器。

+ `max()`：返回迭代器中的最大值。

+ `min()`：返回迭代器中的最小值。

+ `sum()`：计算迭代器中所有元素的和。

+ `product()`：计算迭代器中所有元素的乘积。

+ `any()`：检查迭代器中是否存在满足指定条件的元素。

+ `all()`：检查迭代器中的所有元素是否都满足指定条件。

+ `find()`：查找迭代器中满足指定条件的第一个元素。

+ `position()`：查找迭代器中满足指定条件的第一个元素的索引。

+ `count()`：计算迭代器中的元素个数。

+ `nth()`：获取迭代器中的第n个元素。

+`fold()`：使用一个初始值和一个累加函数对迭代器中的元素进行累积，并返回最终的结果。

+`collect()`：将迭代器中的元素收集到一个集合中，并返回该集合。



### 集合转换
一个通用的编程思路是:
>`CollA` -`iter()`-> `Iterator` -> `Adapters` -> `Iterator` -`collect()`-> `CollB`
在很多函数式语言中都是这种思路来实现的